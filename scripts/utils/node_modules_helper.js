#!/usr/bin/env node
const fs = require('fs')
const path = require('path')
const { builtinModules, createRequire } = require('module')

function usage() {
  console.error(`Usage:
  node node_modules_helper.js resolve <module-name>
  node node_modules_helper.js resolve-from <base-module> <module-name>
  node node_modules_helper.js detect-missing <node-modules-dir> [--with-bases]`)
}

function resolveModuleDir(moduleName) {
  if (!moduleName) {
    usage()
    process.exit(64)
  }

  try {
    // Resolve relative to the caller workspace (cwd) first, which matches pnpm --filter exec
    const cwdReq = createRequire(path.join(process.cwd(), 'package.json'))
    const manifest = cwdReq.resolve(`${moduleName}/package.json`)
    process.stdout.write(path.dirname(manifest))
  } catch (err) {
    // Fallback to Node's default resolver from this script's location
    try {
      const manifest = require.resolve(`${moduleName}/package.json`)
      process.stdout.write(path.dirname(manifest))
    } catch (err2) {
      if (err2 && err2.code === 'MODULE_NOT_FOUND') {
        console.error(`Module "${moduleName}" could not be resolved.`)
        process.exit(3)
      }
      throw err2
    }
  }
}

function resolveFrom(baseModule, targetModule) {
  if (!baseModule || !targetModule) {
    usage()
    process.exit(64)
  }
  const cwdReq = createRequire(path.join(process.cwd(), 'package.json'))
  let baseManifest
  try {
    baseManifest = cwdReq.resolve(`${baseModule}/package.json`)
  } catch (_) {
    try {
      baseManifest = require.resolve(`${baseModule}/package.json`)
    } catch (err) {
      console.error(`Base module "${baseModule}" could not be resolved.`)
      process.exit(3)
    }
  }
  try {
    const baseReq = createRequire(baseManifest)
    const targetManifest = baseReq.resolve(`${targetModule}/package.json`)
    process.stdout.write(path.dirname(targetManifest))
  } catch (err) {
    if (err && err.code === 'MODULE_NOT_FOUND') {
      console.error(`Module "${targetModule}" (from base "${baseModule}") could not be resolved.`)
      process.exit(3)
    }
    throw err
  }
}

function detectMissing(rootDir, opts = { withBases: false }) {
  if (!rootDir) {
    usage()
    process.exit(64)
  }

  const absoluteRoot = path.resolve(rootDir)

  if (!fs.existsSync(absoluteRoot)) {
    console.error(`Directory "${absoluteRoot}" does not exist.`)
    process.exit(2)
  }

  const seen = new Set()
  const packages = []

  function visitNodeModules(dir) {
    if (!dir || seen.has(dir)) return
    seen.add(dir)

    let entries
    try {
      entries = fs.readdirSync(dir, { withFileTypes: true })
    } catch (err) {
      if (err && err.code === 'ENOENT') return
      throw err
    }

    for (const entry of entries) {
      if (entry.name === '.bin') continue
      if (!entry.isDirectory()) continue

      const fullPath = path.join(dir, entry.name)

      if (entry.name.startsWith('@')) {
        visitNodeModules(fullPath)
        continue
      }

      const manifestPath = path.join(fullPath, 'package.json')
      if (!fs.existsSync(manifestPath)) {
        continue
      }

      packages.push({ dir: fullPath, manifestPath })

      const nestedNodeModules = path.join(fullPath, 'node_modules')
      if (fs.existsSync(nestedNodeModules)) {
        visitNodeModules(nestedNodeModules)
      }
    }
  }

  visitNodeModules(absoluteRoot)

  const builtin = new Set(builtinModules)
  const missing = new Map()

  for (const { dir, manifestPath } of packages) {
    let manifest
    try {
      manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'))
    } catch {
      continue
    }

    const deps = manifest.dependencies ? Object.keys(manifest.dependencies) : []
    if (deps.length === 0) continue

    const req = createRequire(manifestPath)

    for (const dep of deps) {
      if (!dep || builtin.has(dep)) continue
      try {
        req.resolve(`${dep}/package.json`)
      } catch (err) {
        if (err && err.code === 'MODULE_NOT_FOUND') {
        if (!missing.has(dep)) missing.set(dep, new Set())
        missing.get(dep).add(dir)
      }
      }
    }
  }

  const missingEntries = Array.from(missing.entries()).sort(([a], [b]) => a.localeCompare(b))

  for (const [dep, dependents] of missingEntries) {
    const dependentsList = Array.from(dependents)
    const requiredBy = dependentsList.join(', ')
    console.error(`Missing module "${dep}" required by: ${requiredBy}`)
    if (opts.withBases) {
      // Derive a base package name from the first dependent path
      const d = dependentsList[0]
      const idx = d.lastIndexOf(`${path.sep}node_modules${path.sep}`)
      let basePkg = ''
      if (idx !== -1) {
        const after = d.slice(idx + (`${path.sep}node_modules${path.sep}`).length)
        const segs = after.split(path.sep).filter(Boolean)
        if (segs.length >= 1) {
          basePkg = segs[0]
          if (basePkg.startsWith('@') && segs.length >= 2) basePkg = `${segs[0]}/${segs[1]}`
        }
      }
      console.log(`${dep}\t${basePkg}`)
    } else {
      console.log(dep)
    }
  }
}

const [, , command, ...args] = process.argv

try {
  switch (command) {
    case 'resolve':
      resolveModuleDir(args[0])
      break
    case 'resolve-from':
      resolveFrom(args[0], args[1])
      break
    case 'detect-missing':
      detectMissing(args[0], { withBases: args.includes('--with-bases') })
      break
    default:
      usage()
      process.exit(64)
  }
} catch (err) {
  console.error(err instanceof Error ? err.message : String(err))
  process.exit(1)
}
