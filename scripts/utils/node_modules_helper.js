#!/usr/bin/env node
const fs = require('fs')
const path = require('path')
const { builtinModules, createRequire } = require('module')

function usage() {
  console.error(`Usage:
  node node_modules_helper.js resolve <module-name>
  node node_modules_helper.js detect-missing <node-modules-dir>`)
}

function resolveModuleDir(moduleName) {
  if (!moduleName) {
    usage()
    process.exit(64)
  }

  try {
    const manifest = require.resolve(`${moduleName}/package.json`)
    process.stdout.write(path.dirname(manifest))
  } catch (err) {
    if (err && err.code === 'MODULE_NOT_FOUND') {
      console.error(`Module "${moduleName}" could not be resolved.`)
      process.exit(3)
    }
    throw err
  }
}

function detectMissing(rootDir) {
  if (!rootDir) {
    usage()
    process.exit(64)
  }

  const absoluteRoot = path.resolve(rootDir)

  if (!fs.existsSync(absoluteRoot)) {
    console.error(`Directory "${absoluteRoot}" does not exist.`)
    process.exit(2)
  }

  const seen = new Set()
  const packages = []

  function visitNodeModules(dir) {
    if (!dir || seen.has(dir)) return
    seen.add(dir)

    let entries
    try {
      entries = fs.readdirSync(dir, { withFileTypes: true })
    } catch (err) {
      if (err && err.code === 'ENOENT') return
      throw err
    }

    for (const entry of entries) {
      if (entry.name === '.bin') continue
      if (!entry.isDirectory()) continue

      const fullPath = path.join(dir, entry.name)

      if (entry.name.startsWith('@')) {
        visitNodeModules(fullPath)
        continue
      }

      const manifestPath = path.join(fullPath, 'package.json')
      if (!fs.existsSync(manifestPath)) {
        continue
      }

      packages.push({ dir: fullPath, manifestPath })

      const nestedNodeModules = path.join(fullPath, 'node_modules')
      if (fs.existsSync(nestedNodeModules)) {
        visitNodeModules(nestedNodeModules)
      }
    }
  }

  visitNodeModules(absoluteRoot)

  const builtin = new Set(builtinModules)
  const missing = new Map()

  for (const { dir, manifestPath } of packages) {
    let manifest
    try {
      manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'))
    } catch {
      continue
    }

    const deps = manifest.dependencies ? Object.keys(manifest.dependencies) : []
    if (deps.length === 0) continue

    const req = createRequire(manifestPath)

    for (const dep of deps) {
      if (!dep || builtin.has(dep)) continue
      try {
        req.resolve(`${dep}/package.json`)
      } catch (err) {
        if (err && err.code === 'MODULE_NOT_FOUND') {
          if (!missing.has(dep)) {
            missing.set(dep, new Set())
          }
          missing.get(dep).add(dir)
        }
      }
    }
  }

  const missingEntries = Array.from(missing.entries()).sort(([a], [b]) => a.localeCompare(b))

  for (const [dep, dependents] of missingEntries) {
    const requiredBy = Array.from(dependents).join(', ')
    console.error(`Missing module "${dep}" required by: ${requiredBy}`)
    console.log(dep)
  }
}

const [, , command, ...args] = process.argv

try {
  switch (command) {
    case 'resolve':
      resolveModuleDir(args[0])
      break
    case 'detect-missing':
      detectMissing(args[0])
      break
    default:
      usage()
      process.exit(64)
  }
} catch (err) {
  console.error(err instanceof Error ? err.message : String(err))
  process.exit(1)
}
